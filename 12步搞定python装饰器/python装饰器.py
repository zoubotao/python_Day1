#!/usr/bin/env python
# -*- coding: utf-8 -*-
# __author__ = "Tsou"
# Email:625139905@qq.com

"""
1.函数
在python中，函数通过def关键字、函数名和可选的参数列表定义。
通过return关键字返回值。
"""
# def foo():
#     return 1
# print(foo())
"""
方法体是必须的，通过缩进来表示，
在方法名的后面加上双括号()就能调用函数
"""

"""
2.作用域
在python中，函数会创建一个新的作用域。
python开发者可能会说函数有自己的命名空间，差不多一个意思。
这意味着在函数内部碰到一个变量的时候，
函数会优先在自己的命名空间里面去寻找。
"""
# a_string = "This is a global variable"
# def foo():
#     print(locals())
# print(globals())  # doctest: +ELLIPSIS
# foo()  # 2
"""
内置的函数globals返回一个包含所有python解释器知道的变量名称的字典。
在#2我调用了函数foo把函数内部本地作用域里面的内容打印出来。
我们能够看到，函数foo有自己独立的命名空间，
虽然暂时命名空间里面什么都还没有。
"""

"""
3.变量解析规则
当然这不是说我们在函数里面就不能访问外面的全局变量。
在Python的作用域规则里面，创建变量一定会在当前作用域里创建一个变量，
但是访问或者修改变量时会先在当前作用域查找变量，
没有找匹配变量的话会依次向上在闭合的作用域里面进行查找。
所有如果我们修改函数foo的实现让它打印全局的作用域里面的变量也是可以的
"""
# a_string = "This is a global variable"
# def foo():
#     print(a_string)  # 1
# foo()
"""
在#1处，pytohn解释器会尝试查找变量a_string，
当然在函数的本地作用域里面是找不到的，
所以接着会去上层的作用域里面去查找。
但是另一方面，假如我们在函数内部给全局变量赋值，结果却和我们想的不一样：
"""
# a_string = "This is a global variable"
# def foo():
#     a_string = "test"  # 1
#     print(locals())
# foo()
# print(a_string)  # 2
"""
我们能够看到，全局变量能够被访问到（如果是可变数据类型（像list，dict这些）甚至能够被更改）但是赋值不行。
在函数内部的#1处，我们实际上创建了一个局部变量，
隐藏全局作用域中的同名变量。
我们可以通过打印出局部命名空间中的内容得出这个结论。
我们也能看到在#2处打印出来的变量a_string的值并没有改变。
"""

"""
4.变量生存周期
值得注意的一个点是，变量不仅是生存在一个个的命名空间内，
他们都有自己的生存周期
"""
# def foo():
#     x = 1
# print(foo())
# print(x)  # 1
"""
#1处发生的错误不仅仅是因为作用域规则导致的（尽管这是抛出了NameError错误的原因）
它还和python以及其他很多编程语言中函数调用实现的机制有关。
在这个地方这个执行时间点并没有什么有效的语法让我们能够获取变量x的值，
因为它这个时候压根不存在！函数foo的命名空间随着函数调用开始而开始，
结束而销毁。
"""

"""
5.函数参数
python允许我们向函数传递参数，参数会变成本地变量存在于函数内部。
"""
# def foo(x):
#     print(locals())
# foo(1)
"""
在python里有很多的方式来定义和传递参数，
完整版可以查看python官方文档。
我们在这里简略的说明一下：
函数的参数可以是必须的位置参数或者是可选的命名，默认参数。
"""
# def foo(x, y=0):  # 1
#     return x - y
# print(foo(3, 1))  # 2
# print(foo(3))  # 3
# print(foo())  # 4
# print(foo(y = 1, x = 3))  # 5
"""
在#1处我们定义了函数foo，它有一个位置参数x和一个命名参数y。
在#2处我们能够通过常规的方式来调用函数，
尽管有一个命名参数，但参数依然可以通过位置传递给函数。
在调用函数的时候，对于命名参数y我们也可以完全不管就像#3处所示的一样。
如果命名参数没有接收到任何值的话，python会自动使用声明的默认值也就是0。
需要注意的是我们不能省略第一个位置参数x，否则的话就会像#4处所示发生错误。
python支持函数调用时的命名参数（个人觉得应该是命名实参）。
看看#5处的函数调用，我们传递的是两个命名实参，这个时候因为有名称标识，
参数传递的顺序也就不用在意了。
当然相反的情况也是正确的：函数的第二个形参是y，
但是我们通过位置的方式传递值给它。在#2处的函数调用foo(3,1)，
我们把3传递给了第一个参数，把1传递给了第二个参数，
尽管第二个参数是一个命名参数。
总结：函数的参数可以有名称和位置。
这意味着在函数的定义和调用的时候会稍稍在理解上有点不同。
我们可以给只定义了位置参数的函数传递命名参数（实参），反之亦然！
"""

"""
6.嵌套函数
python允许创建嵌套函数。
这意味着我们可以在函数里定义函数而且现有的作用域和变量生存周期依旧适用。
"""
# def outer():
#     x = 1
#     def inner():
#         print(x)  # 1
#     inner()  # 2
# outer()
"""
#1发生了什么：python解释器需要找到一个叫x的本地变量，
查找失败之后会继续在上层的作用域里面寻找，
这个上层的作用域定义在另外一个函数里面。
对含糊outer来说，变量x是一个本地变量，但是如先前提到的一样，
函数inner可以访问封闭的作用域（至少可以读和修改）。
在#2处，我们调用函数inner，非常重要的一点是，
inner也仅仅是一个遵循python变量解析规则的变量名，
python解释器会优先在outer的作用域里面对变量名inner查找匹配的变量。
"""

"""
7.函数是python世界里的一级类对象
显而易见，在python里函数和其他东西一样是对象。
"""
# print(issubclass(int, object))  # all objects in Python inherit from a common baseclass
# def foo():
#     pass
# print(foo.__class__)
# print(issubclass(foo.__class__, object))
"""
函数在python里面就是对象，和其他的东西一样。
这就是说你可以把函数像参数一样传递给其他的函数或者从函数里面返回函数。
"""
# def add(x, y):
#     return x + y
# def sub(x, y):
#     return x - y
# def apply(func, x, y):  # 1
#     return func(x, y)  # 2
# print(apply(add, 2, 1))  # 3
# print(apply(sub, 2, 1))
"""
add和sub是非常普通的两个python函数，接收两个值，返回一个计算后的结果。
在#1处你们能看到准备接收一个函数的变量只是一个普通的变量而已，
和其他变量一样。在#2处我们调用传进来的函数：（）代表着调用的操作并且调用变量包含的值。
在#3处，你们也能看到传递函数并没有什么特殊的语法。
函数的名称只是和其他变量一样的标识符而已。
python把频繁要用的操作变成函数作为参数进行使用，
像通过传递一个函数给内置排序函数的key参数从而来定义排序规则。
"""
# def outer():
#     def inner():
#         print("Inside inner")
#     return inner  # 1
# foo = outer()  # 2
# print(foo)
# foo()
"""
在#1处我把恰好是函数标识符的变量inner作为返回值返回出来。
这并没有什么特殊的语法：“把函数inner返回出来，否则它根本不可能会被调用到。”
每次函数outer被调用的时候，函数inner都会被重新定义，
如果它不被当作变量返回的话，每次执行过后它将不复存在。
在#2处我们捕获返回值-函数inner，将它存在一个新的变量foo里。
我们能够看到，当对变量foo进行求值，它确实包含函数inner，
而且我们能够对他进行调用。
"""

"""
8.闭包
#定义：如果在一个内部函数里，对在外部作用域（但不是在全局作用域）的变量进行引用，那么内部函数就被认为是闭包（closure）
分解来说，包含下面3个条件：
1) 需要函数嵌套, 就是一个函数里面再写一个函数.
2) 外部函数需要返回一个内部函数的引用
3) 外部函数中有一些局部变量, 并且, 这些局部变量在内部函数中有使用
一些概念:
1)自由变量: 外部函数中定义的局部变量, 并且在内部函数中被使用
2) 闭包: 那个使用了自由变量并被返回的内部函数就称为闭包

#支持闭包的语言有这样的特性：
1)函数是一阶值（First-class value），即函数可以作为另一个函数的返回值或参数，还可以作为一个变量的值
2)函数可以嵌套定义，即在一个函数内部可以定义另一个函数
"""
# def outer():
#     x = 1
#     def inner():
#         print(x)  # 1
#     return inner  # 加括号返回的是函数执行过程是NoType类型，不加括号返回的是函数内存地址，即函数本身
# foo = outer()
# print(foo.__closure__)  # __closure__里包含了一个元组(tuple)。这个元组中的每个元素是cell类型的对象。
"""
在上一个例子中我们了解到，inner作为一个函数被outer返回，
保存在一个变量foo，并且我们能够对它进行调用foo()。
我们先看看作用域规则，所有的东西都在python的作用域规则下进行工作：
x是函数outer里的一个局部变量。当函数inner在#1处打印x的时候，
python解释器会在inner内部查找相应的变量，当然会找不到，
所以接着会到封闭作用域里面查找，并且会找到匹配。
但是从变量的生存周期来看，变量x是函数outer的一个本地变量，
这意味着只用当函数outer正在运行的时候才会存在。
根据我们已知的python运行模式，我们没法在函数outer返回之后继续调用函数inner，
在函数inner被调用的时候，变量x早已不复存在，可能会发生一个运行时错误。
但是，返回的函数inner居然能够正常工作。
Python支持一个叫函数闭包的特性，简而言之，
嵌套定义在非全局作用域里面的函数能够记住它在被定义的时候所处的封闭命名空间。
这能够通过查看函数的__closure__属性得出结论，
这个属性里面包含封闭作用域里面的值（只会包含被捕捉到的值，比如x，
如果在outer里面还定义了其他的值，封闭作用域里面是不会有的）
记住，每次函数outer被调用的时候，函数inner都会被重新定义。
现在变量x的值不会变化，所以每次返回的函数inner会是同样的逻辑。
"""
# 这是一个另外的例子：
# def line_conf(a, b):
#     def line(x):
#         return a*x + b
#     return line
#
# line1 = line_conf(1, 1)
# line2 = line_conf(4, 5)
# print(line1(5), line2(5))
"""
这个例子中，函数line与环境变量a,b构成闭包。
在创建闭包的时候，我们通过line_conf的参数a,b说明了这两个环境变量的取值，
这样，我们就确定了函数的最终形式(y = x + 1和y = 4x + 5)。
我们只需要变换参数a,b，就可以获得不同的直线表达函数。
由此，我们可以看到，闭包也具有提高代码可复用性的作用。
如果没有闭包，我们需要每次创建直线函数的时候同时说明a,b,x。
这样，我们就需要更多的参数传递，也减少了代码的可移植性。
利用闭包，我们实际上创建了泛函数。
line函数定义一种广泛意义的函数。这个函数的一些方面已经确定(必须是直线)，
但另一些方面(比如a和b参数待定)。
随后，我们根据line_conf传递来的参数，通过闭包的形式，
将最终函数确定下来。
"""
"""
闭包与并行运算
闭包有效的减少了函数所需定义的参数数目。
这对于并行运算来说有重要的意义。
在并行运算的环境下，我们可以让每台电脑负责一个函数，
然后将一台电脑的输出和下一台电脑的输入串联起来。
最终，我们像流水线一样工作，从串联的电脑集群一端输入数据，
从另一端输出数据。这样的情境最适合只有一个参数输入的函数。
闭包就可以实现这一目的。
并行运算正称为一个热点。这也是函数式编程又热起来的一个重要原因。
函数式编程早在1950年代就已经存在，但应用并不广泛。
然而，我们上面描述的流水线式的工作并行集群过程，正适合函数式编程。
由于函数式编程这一天然优势，
越来越多的语言也开始加入对函数式编程范式的支持。
"""

# def outer(x):
#     def inner():
#         print(x)  # 1
#     return inner
# print1 = outer(1)
# print2 = outer(2)
# print1()
# print2()
"""
从这个例子中能看到闭包-被函数记住的封闭作用域-能够被用来创建自定义的函数，
本质上来说是一个硬编码的参数。事实上我们并不是传递参数1或者2给函数inner，
实际上是创建了能够打印各种数字的各种自定义版本。
闭包单独拿出来就是一个非常强大的功能，
在某些方面，也许会把它当作一个类似于面向对象的技术：
outer像是给inner服务的构造器，x像一个私有变量。使用闭包的方式也有很多：
如果熟悉python内置排序方法的参数key，
说不定已经写过一个lambda方法在排序一个列表的时候基于第二个元素而不是第一个。
现在说不定也可以写一个itemgetter方法，接收一个索引值来返回一个完美的函数，
传递给排序函数的参数key
"""

"""
9.装饰器
装饰器其实就是一个闭包，把一个函数当作参数然后返回一个替代版函数。
"""
# def outer(some_func):
#     def inner():
#         print("before some_func")
#         ret = some_func()  # 1
#         return ret + 1
#     return inner
# def foo():
#     return 1
# decorated = outer(foo)  # 2
# print(decorated())
"""
定义了一个函数outer,它只有一个some_func的参数，
在它里面我们定义了一个嵌套的函数inner。inner会打印一串字符串，
然后调用some_func，在#1处得到它的返回值。
在outer每次调用的时候，some_func的值可能会不一样，
但是不管some_func的值如何，我们都会调用它。最后，
inner返回some_func() + 1的值-我们通过调用在#2处存储在变量decorated里面的函数能够看到被打印出来的字符串以及返回值2，
而不是期望中调用函数foo得到的返回值1。
我们可以认为变量decorated是函数foo的一个装饰版本，一个加强版本。
事实上如果打算写一个有用的装饰器的话，我们可能会愿意用装饰版本完全取代原先的函数foo，
这样我们总是会得到我们的“加强版”foo。想要达到这个效果，
完全不需要学习新的语法，简单的赋值给变量foo就行
"""
# foo = outer(foo)
# print(foo())
"""
现在，无论怎么调用都不会牵扯到原先的函数foo，都会得到新的装饰版本的foo。
现在写一个有用的装饰器。想象一个库，这个库能够提供类似坐标的对象，
也许仅仅是一些x和y的坐标对。不过可惜的是这些坐标对象不支持数学运算符，
而且我们也不能对源代码进行修改，因此也就不能直接加入运算符的支持。
我们将会做一系列的数学运算，
所以我们想要能够对两个坐标对象进行合适加减运算的函数。
"""
# class Coordinate(object):
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y
#     def __repr__(self):
#         return "Coord:" + str(self.__dict__)
# def add(a, b):
#     return Coordinate(a.x + b.x, a.y + b.y)
# def sub(a, b):
#     return Coordinate(a.x - b.x, a.y - b.y)
# one = Coordinate(100, 200)
# two = Coordinate(300, 200)
# print(add(one, two))
"""
如果我们的加减函数同时也需要一些边界检查的行为该怎么办？
例如只能对正的坐标对象进行加减操作，任何返回的值也都应该是正的坐标。
现在是这样：
one = Coordinate(100, 200)
two = Coordinate(300, 200)
three = Coordinate(-100, -100)
sub(one, two)
Coord: {'y': 0, 'x': -200}
add(one, three)
Coord: {'y': 100, 'x': 0}
我们期望在不更改坐标对象one,two,three的前提下one减去two的值是{x:0,y:0}，
one加上three的值是{x:100,y:200}。
与其给每个方法都加上参数和返回值边界检查的逻辑，来写一个边界检查的装饰器
"""
# three = Coordinate(-100, -100)
# def wrapper(func):
#     def checker(a, b):  # 1
#         if a.x < 0 or b.y < 0:
#             a = Coordinate(a.x if a.x > 0 else 0, a.y if a.y > 0 else 0)
#         if b.x < 0 or b.y < 0:
#             b = Coordinate(b.x if b.x > 0 else 0, b.y if b.y > 0 else 0)
#         ret = func(a, b)
#         if ret.x < 0 or ret.y < 0:
#             ret = Coordinate(ret.x if ret.x > 0 else 0, ret.y if ret.y > 0 else 0)
#         return ret
#     return checker
# add = wrapper(add)
# sub = wrapper(sub)
# print(sub(one, two))
# print(add(one, three))
"""
这个装饰器能像先前的装饰器一样进行工作，返回一个经过修改的函数，
但是在这个例子中，它能够对函数的输入参数和返回值做一些非常有用的检查和格式化工作，
将负值的x和y替换成0。
显而易见，通过这样的方式，我们的代码变得更加简洁：
将边界检查的逻辑隔离到单独的方法中，然后通过装饰器包装的方式应用到我们需要进行检查的地方。
另外一种方式通过在计算方法的开始处和返回值之前调用边界检查的方法也能够达到同样的目的。
但是不置可否的是，使用装饰器能够让我们以最小的代码量达到坐标边界检查的目的。
事实上，如果我们是在装饰自己定义的方法的话，我们能够让装饰器应用的更加有逼格。
"""

"""
10.使用@标识符将装饰器应用到函数
Python2.4支持使用标识符@将装饰器应用在函数上，只需要在函数的定义前加上@和装饰器的名称。
在上一节的例子里我们是将原本的方法用装饰的方法代替：
add = wrapper(add)
这种方式能够在任何时候对任意方法进行包装。但是如果我们自定义一个方法，
我们可以使用@进行装饰
@wrapper
def add(a,b):
    return Coordinate(a.x + b.x, a.y + b.y)
需要明白的是，这样的做法和先前简单的用包装方法替代原有方法上是一样的，
python只是加了一些语法糖让装饰的行为更加的直接明确和优雅一点。
"""
# def log(func):
#     def wrapper(*args, **kw):
#         print("call %s()" % func.__name__)
#         return func(*args, **kw)
#     return wrapper
# @log  # 必须在被修饰函数的前一行，不能修饰类
# def now():
#     print('2017-06-19')
# now()

"""
11.*args and **kwargs
我们已经完成了一个有用的装饰器，但是由于硬编码的原因它只能应用在一类具体的方法上，
这类方法接收两个参数，传递给闭包捕获的函数。
如果我们想实现一个能够应用在任何方法上的装饰器要怎么做呢？
再比如，如果我们要实现一个能应用在任何方法上的类似于计数器的装饰器，
不需要改变原有方法的任何逻辑。
这意味着装饰器能够接受拥有任何签名的函数作为自己的被装饰方法，
同时能够用传递给它的参数对被装饰的方法进行调用。
Python正好有支持这个特性的语法。可以阅读Python Tutorail获取更多的细节。
当定义函数的使用了*，意味着那些通过位置传递的参数将会被放在带有*前缀的变量中。
"""
# def one(*args):
#     print(args)  # 1
# one()
# one(1,2,3)
# def two(x,y, *args):  # 2
#     print(x, y, args)
# two('a','b','c')
"""
第一个函数one只是简单的将任何传递过来的位置参数全部打印出来而已，
能够看到，在代码#1处我们只是引用了函数内的变量args，
*args仅仅只是用在函数定义的时候用来表示位置参数应该存储在变量args里面。
Python允许我们制定一些参数并且通过args捕获其他所有剩余的未被捕获的位置参数，
就像#2处所示的那样。*操作符在函数被调用的使用也能使用。
意义基本是一样的。当调用一个函数的时候，
一个用*标志的变量意思是变量里面的内容需要被提取出来然后当做位置参数被使用。
"""
# def add(x,y):
#     return x + y
# lst = [1,2]
# print(add(lst[0], lst[1]))  # 1
# print(add(*lst))  # 2
"""
#1处的代码和#2处的代码所做的事情其实是一样的，
在#2处，python为我们所做的事其实也可以手动完成。
*args要么是表示调用方法的时候额外的参数可以从一个可迭代列表中取得，
要么就是定义方法的时候标志这个方法能够接受任意的位置参数。
**代表着键值对的参数字典，和*所代表的意义相差无几。
"""
# def foo(**kwargs):
#     print(kwargs)
# foo()
# foo(x = 1, y = 2)
"""
当我们定义一个函数的时候，我们能够用**kwargs来表明所有未被捕获的关键字参数都应该存储在kwargs的字典中。
args和kwargs并不是python语法的一部分，但是在定义函数的时候，使用这样的变量名算是一个不成文的约定。
和*一样，我们同样可以在定义或者调用函数的时候使用**。
"""
# dct = {'x':1 , 'y':2}
# def bar(x,y):
#     return x+y
# print(bar(**dct))

"""
12.更通用的装饰器
写一个能够记录下传递给函数参数的装饰器。
"""
def logger(func):
    def inner(*args, **kwargs):  # 1
        print("Arguments were: %s, %s" % (args, kwargs))
        return func(*args, **kwargs)  # 2
    return inner
"""
请注意函数inner，它能够接受任意数量和类型的参数并把它们传递给被包装的方法。
"""
@logger
def foo1(x, y=1):
    return x*y
@logger
def foo2():
    return 2
print(foo1(5,4))
print(foo1(1))
print(foo2())
"""
随便调用定义的哪个方法，相应的日志也会打印到输出窗口。
"""